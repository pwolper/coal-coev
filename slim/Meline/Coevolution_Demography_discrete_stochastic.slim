// parameters to enter in comand lines (-d option)

// repID

// Start of the simulation
species all initialize() {
	initializeSLiMModelType("nonWF");
	//	defineConstant("mu_neutral", 500);	// mutation rate of neutral loci
	//defineConstant("H_init", 9960); // Initial number of hosts
	//defineConstant("P_init", 1660); // Initial number of parasites (and thus of infected hosts, one parasite per host)
	defineConstant("HealthyInit", c(4150,4150)); // Vector, HealthyInit[i] initial number of hosts of genotype i
	defineConstant("InfectedInit", matrix(c(415, 415, 415, 415), nrow=2)); //  Matrix, InfectedInit[i][j] initial number of hosts of genotype i infected by parasites of genotype j
	defineConstant("G_host", 1); // Relative generation time scale for hosts (compared to parasite which is 1)
	defineConstant("b", 2.); // Host birth rate 
	defineConstant("d", 0.5); // Host death rate
	defineConstant("K", 10000); // Host carrying capacity for the reproduction
	defineConstant("cH", c(0.05, 0)); // Vector of Fitness cost of host genotypes 
	defineConstant("cP", c(0, 0.05)); // Vector of Fitness cost of pathogen genotypes 
	// defineConstant("S", matrix(c(0.1,0.1,0.1,0.1), nrow=2)); // Fitness disavantage of infected hosts (birth rate 1-S)
	defineConstant("S", 1); // Fitness disavantage of infected hosts (birth rate 1-S)
	// defineConstant("B", matrix(c(0.1,0.1,0.1,0.1), nrow=2)); // transmission rate 
	defineConstant("B", 0.00037); // transmission rate 
	//defineConstant("D", matrix(c(0.1,0.1,0.1,0.1), nrow=2)); // Extra death rate due to infection 
	defineConstant("D", 0.01); // Extra death rate due to infection  
	defineConstant("alpha", matrix(c(1,0,1,1), nrow=2)); // Matrix alpha of infection, hosts in rows and pathogens in columns (Matrices are filled column by column in SLiM)
	defineConstant("PositionSNP", 50); // Position of the selected locus on the first chromosome  
	defineConstant("SizeChromosome", 100); // Size of each chromosome
}

species parasite initialize() {
	// The order in which you define species (here first parasite then host), rules also the order of the reproduction events
	// Here, the parasite must be defined soon, because the number of parasite offspring depends on the number of hosts, so if the host reproduces first, it changes the parasite offsprings
	// The parasite reproduces first, and as they stay in the same host (which was already infected) until the migration step in early(), it does not change the number of host offspring
	initializeSpecies(avatar="ðŸ„", color="red");
	
	// initializeMutationRate(1e-6); // Uncomment only if we want a fix mutation rate for all mutations, included the non-neutral SNP
	initializeMutationType("m1", 1.0, "f", 0.0); // neutral mutations
	initializeMutationType("m2", 1.0, "f", 0.0); // SNP: initialised as neutral mutation, but selected, see the rest of the code
	m1.convertToSubstitution = T;
	m2.convertToSubstitution = F;
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElementType("g2", m2, 1.0);
	initializeGenomicElement(g1, 0, PositionSNP-1);
	initializeGenomicElement(g2, PositionSNP, PositionSNP); // SNP in the middle of the first chromosome
	initializeGenomicElement(g1, PositionSNP+1, 2*SizeChromosome-1);
	rates = c(1e-6, 0.5, 1e-6);
	ends = c(SizeChromosome-1, SizeChromosome, 2*SizeChromosome-1);
	initializeRecombinationRate(rates, ends);
	
	// Use the mutation rate map to vary the mutation rate depending on the genomic region (no mutation for the non-neutral SNP)
	ends = c(PositionSNP-1, PositionSNP, 2*SizeChromosome-1);
	mutationRates = c(1e-6, 0, 1e-6);
	initializeMutationRate(mutationRates, ends);
}

species host initialize() {
	initializeSpecies(tickModulo=G_host, avatar="ðŸŒ±", color="green");
	initializeSLiMOptions(keepPedigrees=T); // pedigree IDs are used to identify host-parasite matches: each host has a unique pedigreeID value.
	// For each host, there will exist a separate pathogen subpopulation containing all of the pathogens that are living in that host
	// For a given host with a particular pedigreeID , the corresponding pathogen subpopulationâ€™s tag value will be equal to the hostâ€™s pedigreeID
	
	// host.tag corresponds to the number of parasites on each host
	
	// initializeMutationRate(1e-6); // Uncomment only if we want a fix mutation rate for all mutations, included the non-neutral SNP
	initializeMutationType("m3", 1.0, "f", 0.0); // neutral mutations
	initializeMutationType("m4", 1.0, "f", 0.0); // SNP: initialised as neutral mutation, but selected, see the rest of the code
	m3.convertToSubstitution = T;
	m4.convertToSubstitution = F;
	initializeGenomicElementType("g3", m3, 1.0);
	initializeGenomicElementType("g4", m4, 1.0);
	initializeGenomicElement(g3, 0, PositionSNP-1);
	initializeGenomicElement(g4, PositionSNP, PositionSNP); // SNP in the middle of the first chromosome
	initializeGenomicElement(g3, PositionSNP+1, 2*SizeChromosome-1);
	rates = c(1e-6, 0.5, 1e-6);
	ends = c(SizeChromosome-1, SizeChromosome, 2*SizeChromosome-1);
	initializeRecombinationRate(rates, ends);
	
	// Use the mutation rate map to vary the mutation rate depending on the genomic region (no mutation for the non-neutral SNP)
	ends = c(PositionSNP-1, PositionSNP, 2*SizeChromosome-1);
	mutationRates = c(1e-6, 0, 1e-6);
	initializeMutationRate(mutationRates, ends);
}

// create initial populations
ticks all 1 first() {
	host.addSubpop("p1", sum(HealthyInit)+sum(InfectedInit), haploid=T);
	
	// tag with the number of parasites in each host
	p1.individuals.tag = 0;
	
	// Choose initial hosts carrying the mutated SNP (genotype 2)
	targetH = sample(p1.individuals.genome1,HealthyInit[1] + InfectedInit[1,0]+InfectedInit[1,1]);
	targetH.addNewDrawnMutation(m4, PositionSNP);
	
	// choose initial hosts carrying the infection, for each host genotype, from matrix InfectedInit
	initial_inf_hosts_1 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==0],InfectedInit[0,0]+InfectedInit[0,1],replace=F); // Works only if there is one parasite per infected host, otherwise, consider different values for P_init and the initial number of infected hosts
	initial_inf_hosts_2 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)>0],InfectedInit[1,0]+InfectedInit[1,1],replace=F); // Works only if there is one parasite per infected host, otherwise, consider different values for P_init and the initial number of infected hosts
	
	initial_inf_hosts_1.tag=1; // theses hosts are infected
	initial_inf_hosts_2.tag=1; // theses hosts are infected
	parasite.tag = 3;
	
	initial_inf_hosts = matrix(c(initial_inf_hosts_1,initial_inf_hosts_2),ncol=2); // matrix of the initial infected hosts, heach host genotype is a column (column for genotype 1 and for genotype 2)
	
	for (i in 0:(dim(initial_inf_hosts)[1]-1)) // Loop on the number of columns (the number of host genotypes i)
	{
		for (initial_inf_host in initial_inf_hosts[0:(InfectedInit[i,0][0]-1),i]) // Loop on all selected hosts individuals to be infected by parasites of genotype 1
		{
			// make a parasite subpop for the host
			parasite_subpop = parasite.addSubpop(parasite.tag, 1, haploid=T); // Each new parasite subpopulation gets a new id â€“ p3 , p4 , p5 , etc. â€“ based upon the value of the tag value on the parasite species; 
			parasite_subpop.tag = initial_inf_host.pedigreeID; // tag value for the subpopulation equal to the target host's pedigreeID . This establishes the correspondence between the hosts and the parasites infecting them.
			parasite.tag = parasite.tag + 1; // that tag value gets incremented after each new subpopulation is created, providing unique identifier values
		}
		for (initial_inf_host in initial_inf_hosts[InfectedInit[i,0][0]:(dim(initial_inf_hosts)[0]-1),i]) // Loop on all selected hosts individuals to be infected by parasites of genotype 2
		{
			// make a parasite subpop for the host
			parasite_subpop = parasite.addSubpop(parasite.tag, 1, haploid=T); // Each new parasite subpopulation gets a new id â€“ p3 , p4 , p5 , etc. â€“ based upon the value of the tag value on the parasite species; 
			parasite_subpop.tag = initial_inf_host.pedigreeID; // tag value for the subpopulation equal to the target host's pedigreeID . This establishes the correspondence between the hosts and the parasites infecting them.
			// Add a mutation
			parasite_subpop.individuals.genome1.addNewDrawnMutation(m2, PositionSNP);
			
			parasite.tag = parasite.tag + 1; // that tag value gets incremented after each new subpopulation is created, providing unique identifier values
		}
	}
	
	// Preparation of the output file
	
	//defineConstant("simID", getSeed()); // COnstant to name each output file for each replicate
	// log = community.createLogFile("sim_log_" + repID + ".txt", logInterval=1);
	log = community.createLogFile("sim_log_b" + b + "_d" + d + "_B" + B + ".txt", logInterval=1);
	
	log.addCycle(host);
	log.addCycle(parasite);
	log.addCustomColumn("N_H", "p1.individualCount;");
	log.addCustomColumn("N_P", "parasite.subpopulations.individuals.size();");
	log.addCustomColumn("nbSNP_H", "p1.individuals.genome1.mutationsOfType(m4).size();");
	log.addCustomColumn("nbSNP_P", "parasite.subpopulations.individuals.genome1.mutationsOfType(m2).size();");
	log.addCustomColumn("nbHealthy_1", "sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)==0);");
	log.addCustomColumn("nbHealthy_2", "sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4));");
	log.addCustomColumn("nbInfected_1", "sum(p1.individuals[p1.individuals.tag>0].genome1.countOfMutationsOfType(m4)==0);");
	log.addCustomColumn("nbInfected_2", "sum(p1.individuals[p1.individuals.tag>0].genome1.countOfMutationsOfType(m4));");
}

//ticks all 1 first() {
//	// Introduce mutated SNP in one hosts and parasites at the selected locus
//	targetH = sample(p1.individuals.genome1,1);
//	targetH.addNewDrawnMutation(m4, PositionSNP);
//	
//	parasiteSubpops = parasite.subpopulations;
//	allParasites = parasiteSubpops.individuals;
//	targetP = sample(allParasites.genome1,1);
//	targetP.addNewDrawnMutation(m2, PositionSNP);
//}

//ticks all first() {
//	// We need to store the parasite and host population sizes before the reproduction event, to get them at the time of death
//	nb_Healthy = p1.individuals[p1.individuals.tag==0].size(); //number of healthy hosts
//	nb_Infected = p1.individuals[p1.individuals.tag>0].size(); // number of infected hosts
//	host.setValue("nb_host_offspring",asInteger(round(b*(nb_Healthy+(1-S)*nb_Infected)))); // count the number of offspring to generate, reinitialized at each new tick cycle
//	host.setValue("offspring_generated",0); // count the number of offspring already generated, reinitialized at each new tick cycle
//	
//	parasiteSubpops = parasite.subpopulations;
//	allParasites = parasiteSubpops.individuals;
//	parasite.setValue("nb_parasite_offspring",asInteger(round(allParasites.size() * p1.individuals.size() * B))); // count the number of offspring to generate, reinitialized at each new tick cycle
//	parasite.setValue("offspring_generated",0); // count the number of offspring already generated, reinitialized at each new tick cycle
//
//}

ticks all first() {
	// We need to store the parasite destination of migration before the reproduction event: 0: no migration; 1: towards hosts of genotype 1; 2: towards hosts of genotype 2
	parasiteSubpops = parasite.subpopulations;
	allParasites = parasiteSubpops.individuals;
	allParasites.setValue("migration_towards",0); // All individuals before reproduction are staying on their host: only new individuals will migrate to a new host
}

species parasite reproduction() {
	
	nb_Healthy = p1.individuals[p1.individuals.tag==0].size(); //number of healthy hosts
	parasiteSubpops = parasite.subpopulations;
	allParasites = parasiteSubpops.individuals;
	
	nb_Healthy_H2 = sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)); // Number of mutations at the selected SNP m4 for the healthy host population --> number of healthy hosts of genotype 2
	nb_Healthy_H1 = sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)==0); // Number of healthy hosts with no mutation at the selected SNP m4 --> number of healthy hosts of genotype 1
	
	nb_P2 = sum(allParasites.genome1.countOfMutationsOfType(m2)); // Number of mutations at the selected SNP m2 for the parasite population --> number of parasites of genotype 2
	nb_P1 = sum(allParasites.genome1.countOfMutationsOfType(m2)==0); // Number of parasite individuals with no mutation at the selected SNP m2 --> number of parasites of genotype 1
	
	// To calculate the total number of generated offspring, we calculate the number of offspring that should be generated for each genotype class from the equations (actually we will draw random parents, so these genotype classes of offspring and their migration will not be exatly the same than here, beacuse of the stochasticity)
	nb_parasite_offspring_P1H1 = nb_P1 * nb_Healthy_H1 * B * alpha[0,0] * (1-cP[0]); // nb of offspring P1 that will migrate on hosts H1
	nb_parasite_offspring_P1H2 = nb_P1 * nb_Healthy_H2 * B * alpha[1,0] * (1-cP[0]); // nb of offspring P1 that will migrate on hosts H2
	nb_parasite_offspring_P2H1 = nb_P2 * nb_Healthy_H1 * B * alpha[0,1] * (1-cP[1]); // nb of offspring P2 that will migrate on hosts H1
	nb_parasite_offspring_P2H2 = nb_P2 * nb_Healthy_H2 * B * alpha[1,1] * (1-cP[1]); // nb of offspring P2 that will migrate on hosts H2
	
	// Total number of offspring to generate that will survive and migrate on a new host
	Tot_nb_offspring = asInteger(round(nb_parasite_offspring_P1H1 + nb_parasite_offspring_P1H2 + nb_parasite_offspring_P2H1 + nb_parasite_offspring_P2H2)) ;
	
	nb_offspring = 0 ; // Count the number of already generated offsprings
	
	while	(nb_offspring<Tot_nb_offspring)
	{
		// Probabilities to draw randomly a parent of genotype 1
		Proba_G1 = nb_P1*(1-cP[0])/(nb_P1*(1-cP[0])+nb_P2*(1-cP[1])) ;
		
		// Draw two random numbers between 0 and 1 to determine the genotype of parents 1 and 2
		p = runif(n=2,min=0,max=1);
		
		if (p[0]<Proba_G1){GP1 = 0;} // Genotype of parent 1 is 1 (coded 0)
		else {GP1 = 1;} // Genotype of parent 1 is 2 (coded 1)
		
		if (p[1]<Proba_G1){GP2 = 0;} // Genotype of parent 2 is 1 (coded 0)
		else {GP2 = 1;} // Genotype of parent 2 is 2 (coded 1)
		
		// Sample two parents for each offspring, selfing allowed
		parent1 = sample(allParasites[allParasites.genome1.countOfMutationsOfType(m2)==GP1],1) ;
		parent2 = sample(allParasites[allParasites.genome1.countOfMutationsOfType(m2)==GP2],1) ;
		
		breaks = parasite.chromosome.drawBreakpoints(parent1);
		
		// Check which allele is drawn for the offspring SNP
		polarity = sum(breaks <= PositionSNP) % 2; // 0 for the same allele than parent1, 1 for the same allele than parent2
		
		// Allele 0 for genotype 1 and 1 for genotype 2
		if (polarity==0){allele = parent1.genome1.countOfMutationsOfType(m2);}
		else {allele = parent2.genome1.countOfMutationsOfType(m2);}
		
		// Depending of the offspring allele, see if the offspring survive the migration to a host, if yes generate it
		// 1. Which host genotype will the parasite encounter for the migration?
		
		// probability to migrate on healthy hosts of genotype 1, depending of the number of hosts
		Proba_H1 = nb_Healthy_H1/(nb_Healthy_H1+nb_Healthy_H2);
		
		pH1 = runif(n=1,min=0,max=1);
		
		if (pH1<Proba_H1){migrate_to = 1;} // The parasite encounter a host of genotype 1 
		else {migrate_to = 2;} // The parasite encounter a host of genotype 2
		
		// 2. Does the parasite succeed to infect this host? 
		p_survival = alpha[migrate_to-1,allele] ; // Probability of infection for a parasite of genotype allele migrating on a host of genotype migrate_to-1
		
		ps = runif(n=1,min=0,max=1); // random number between 0 and 1
		
		if (ps<p_survival) // The parasite survives and the offspring is generated
		{
			Subpop = parasiteSubpops[parasiteSubpops.individuals == parent1];
			// Add the new parasite to the subpopulation, and indicates towards which host type it will migrate next
			Subpop.addRecombinant(parent1.genome1, parent2.genome1, breaks, NULL, NULL, NULL).setValue("migration_towards",migrate_to);
			nb_offspring = nb_offspring+1 ;
		}
	}
	self.active = 0; // This reproduction callback will be applied only once, and all offspring are generated	
}

species host reproduction() {
	
	// Number of host for each category of genotype and infection
	nb_Healthy_H1 = sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)==0); // Number of healthy hosts with no mutation at the selected SNP m4 --> number of healthy hosts of genotype 1
	nb_Healthy_H2 = sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)); // Number of mutations at the selected SNP m4 for the healthy host population --> number of healthy hosts of genotype 2
	nb_Infected_H1 = sum(p1.individuals[p1.individuals.tag>0].genome1.countOfMutationsOfType(m4)==0); // Number of infected hosts of genotype 2
	nb_Infected_H2 = sum(p1.individuals[p1.individuals.tag>0].genome1.countOfMutationsOfType(m4)); // Number of infected hosts of genotype 2
	
	// To calculate the total number of generated offspring, we calculate the number of offspring that should be generated for each genotype class from the equations (actually we will draw random parents, so these genotype classes of offspring will not be exatly the same than here, beacuse of the stochasticity)
	nb_healthy_offspring_H1 = asInteger(round(b*(1-cH[0])*nb_Healthy_H1*(1-((nb_Healthy_H1+nb_Healthy_H2+nb_Infected_H1+nb_Infected_H2)/(K/(1-d)))))); // Number of offspring of genotype 1, with a healthy parent
	nb_infected_offspring_H1 = asInteger(round(b*(1-cH[0])*(1-S)*nb_Infected_H1*(1-((nb_Healthy_H1+nb_Healthy_H2+nb_Infected_H1+nb_Infected_H2)/(K/(1-d))))));	// Number of offspring of genotype 1, with an infected parent
	nb_healthy_offspring_H2 = asInteger(round(b*(1-cH[1])*nb_Healthy_H2*(1-((nb_Healthy_H1+nb_Healthy_H2+nb_Infected_H1+nb_Infected_H2)/(K/(1-d)))))); // Number of offspring of genotype 2, with a healthy parent
	nb_infected_offspring_H2 = asInteger(round(b*(1-cH[1])*(1-S)*nb_Infected_H2*(1-((nb_Healthy_H1+nb_Healthy_H2+nb_Infected_H1+nb_Infected_H2)/(K/(1-d)))))); // Number of offspring of genotype 2, with an infected parent
	
	// Total number of offspring to generate
	Tot_nb_offspring = nb_healthy_offspring_H1 + nb_infected_offspring_H1 + nb_healthy_offspring_H2 + nb_infected_offspring_H2 ;
	
	// Calculate the probabilities that a parent belong to one of the four categories : healthyH1, healthyH1, infectedH1, infectedH2
	p_healthyH1 = nb_healthy_offspring_H1/Tot_nb_offspring ;
	p_healthyH2 = nb_healthy_offspring_H2/Tot_nb_offspring ;
	p_infectedH1 = nb_infected_offspring_H1/Tot_nb_offspring ;
	p_infectedH2 = nb_infected_offspring_H2/Tot_nb_offspring ;
	
	nb_offspring = 0 ; // Count the number of already generated offsprings
	
	while	(nb_offspring<Tot_nb_offspring)
	{
		// Generate two random numbers between 0 and 1 to determine the category of each parent
		p = runif(n=2,min=0,max=1);
		
		// Randomly draw parent 1 depending on the value of p[0]
		if (p[0]<p_healthyH1){parent1 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==0 & p1.individuals.tag==0],1);}
		else if (p[0]<(p_healthyH1+p_healthyH2)){parent1 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==1 & p1.individuals.tag==0],1);}
		else if (p[0]<(p_healthyH1+p_healthyH2+p_infectedH1)){parent1 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==0 & p1.individuals.tag==1],1);}
		else {parent1 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==1 & p1.individuals.tag==1],1);}
		
		// Randomly draw parent 2 depending on the value of p[1]
		if (p[1]<p_healthyH1){parent2 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==0 & p1.individuals.tag==0],1);}
		else if (p[1]<(p_healthyH1+p_healthyH2)){parent2 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==1 & p1.individuals.tag==0],1);}
		else if (p[1]<(p_healthyH1+p_healthyH2+p_infectedH1)){parent2 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==0 & p1.individuals.tag==1],1);}
		else {parent2 = sample(p1.individuals[p1.individuals.genome1.countOfMutationsOfType(m4)==1 & p1.individuals.tag==1],1);}
		
		// Generate the offspring
		breaks = host.chromosome.drawBreakpoints(parent1);
		subpop.addRecombinant(parent1.genome1, parent2.genome1, breaks, NULL, NULL, NULL);
		nb_offspring = nb_offspring+1 ;
	
	}
	self.active = 0; // This reproduction callback will be applied only once, and all offspring individuals are generated in this unique callback	
}

ticks all early() {
	
	////////////////////////// horizontal transmission
	// Here, we perform the migration of new parasites after the reproduction events, and we do not select the host on which parasites migrate depending on their age
	// This means that new parasites can infect new hosts, otherwise new host are imune to the parasite the first year, and as we aplied a carrying capacity, host population can never go extinct and is not subjected to selection anymore
	if (p1.individuals.size() > 1)
	{
		// For each host, check if it is infected more than once
		parasiteSubpops = parasite.subpopulations;
		for (h in p1.individuals)
		{
			hostID = h.pedigreeID;
			parasiteSubpop = parasiteSubpops[parasiteSubpops.tag == hostID];
			h.tag =  parasiteSubpop.individuals.size();
		}
		
		//		print(sum(p1.individuals.tag));
		//		nb_Healthy = p1.individuals[p1.individuals.tag==0].size(); //number of healthy hosts
		//		nb_Infected = p1.individuals[p1.individuals.tag>0].size(); // number of infected hosts
		//		print(nb_Healthy);
		//		print(nb_Infected);
		//		print(p1.individuals[p1.individuals.tag==1].size());
		//		print(p1.individuals[p1.individuals.tag==2].size());
		//		print(p1.individuals[p1.individuals.tag==3].size());
		
		moving = p1.individuals[p1.individuals.tag>=2]; // host from witch parasites will move
		infected = p1.individuals[p1.individuals.tag>=1]; // host already infected
		
		for (h in moving) // LATER :  verifiy here that there is no biais in the order to migrate (ex if there a more parasites migrating than healthy hosts, it is always the last hosts of the list moving thant will kill their parasites, reshufle the list moving instead? We can use "sample" to reshuffle randomly, to do
		{
			// figure out which host we are in
			hostID = h.pedigreeID;
			
			// Curent parasite population
			parasiteSubpop = parasiteSubpops[parasiteSubpops.tag == hostID];
			// parasites in the current host
			parasites_current_host = parasiteSubpop.individuals;
			// number of parasites in the current host :
			nb_parasites = parasites_current_host.size();
			
			// For all individuals on the concerned host, perform the migration depending on "migration_towards": 
			// 0 the parasite does not migrate (it is the parent individual), 1 it migrates towards a healthy host of genotype 1, 2 it migrates towards a host of genotype 2
			for(p in parasiteSubpop.individuals)
			{
				// get the value of "migration_towards"
				mig_towards = p.getValue("migration_towards");
				if(mig_towards>0)
				{
					
					// ATTENTION MODIFIER: Comment gerer le stacking de mutations ici, si deux mutations stack au niveau du SNP, on a un troisieme allele! Recoder pour faire une mutation reverse a la place. Pour l'instant pas de mutation au niveau de l4allele sous selection donc pas de probleme
					//if(p1.individuals[p1.individuals.tag==0 & p1.individuals.age>0].size()>=1) // We want at least one non infected (and not newly born) host for the migration
					
					// List of available hosts to consider for the migration of p: healty host, and with the correct genotype
					Available_hosts = p1.individuals[p1.individuals.tag==0 & p1.individuals.genome1.countOfMutationsOfType(m4)==(mig_towards-1)];
					
					// We want at least one host available for the migration to take place
					if(Available_hosts.size()>0)
					{
						// choose a different host (non infected, and not a new host) and get its ID
						newHost = sample(Available_hosts,1);
						newHostID = newHost.pedigreeID;
						
						// Create a subpop for the new host and move to it
						newSubpop = parasite.addSubpop(parasite.tag, 0);
						parasite.tag = parasite.tag + 1;
						newSubpop.tag = newHostID;
						
						newSubpop.takeMigrants(p);
						
						// add this new host in the list of infected hosts	
						newHost.tag=1;
						h.tag=h.tag-1;
						infected = p1.individuals[p1.individuals.tag>=1];
					}
					else // If there is no non infected host available for the migration, we will remove the extra parasites
					{
						parasite.killIndividuals(p);
						h.tag=h.tag-1;
					}
				}
			}
		}
		// color infected hosts
		infected.color = "blue";
	}
	
	// Check if some host still have more than one parasite: return an error
	if (p1.individuals[p1.individuals.tag>1].size()>0)
		stop("Error: More than one parasite per host");
	
	////////////////////////// disease outcome: additionnal host mortality
	// To build proper equations, without intermediate time steps between ticks, calculate death rates from the population size before the reproduction events
	// However, allow new hosts to die: if we only allow parents to die, new hosts are not subject to selection, and it can lead to a limit case with the mortality of each host except the new each year, which will completely erase the selection (because of this immunity period)
	
	parasiteSubpops = parasite.subpopulations;
	
	nb_Healthy_H1 = sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)==0); // Number of healthy hosts of genotype 1
	nb_Healthy_H2 = sum(p1.individuals[p1.individuals.tag==0].genome1.countOfMutationsOfType(m4)); // Number of healthy hosts of genotype 2
	nb_Infected_H1 = sum(p1.individuals[p1.individuals.tag>0].genome1.countOfMutationsOfType(m4)==0); // Number of infected hosts of genotype 2
	nb_Infected_H2 = sum(p1.individuals[p1.individuals.tag>0].genome1.countOfMutationsOfType(m4)); // Number of infected hosts of genotype 2
	
	nb_Healthy_death_H1 = asInteger(round(nb_Healthy_H1*d)); // Number of healthy hosts of genotype 1 that will die
	nb_Healthy_death_H2 = asInteger(round(nb_Healthy_H2*d)); // Number of healthy hosts of genotype 2 that will die
	// PROBLEME HERE: With one parasite left, it can never die, if d+D<0.5 because round(d+D)=0
	nb_Infected_death_H1 = asInteger(round(nb_Infected_H1*(d+D))); // Number of infected hosts of genotype 1 that will die
	nb_Infected_death_H2 = asInteger(round(nb_Infected_H2*(d+D))); // Number of infected hosts of genotype 2 that will die
	
	// Calculate the total number of death
	nb_host_death =  nb_Healthy_death_H1+nb_Healthy_death_H2+nb_Infected_death_H1+nb_Infected_death_H2;
	
	// Probabilities to die for each host category
	
	p_death_healthyH1 = nb_Healthy_death_H1/nb_host_death ;
	p_death_healthyH2 = nb_Healthy_death_H2/nb_host_death ;
	p_death_infectedH1 = nb_Infected_death_H1/nb_host_death ;
	p_death_infectedH2 = nb_Infected_death_H2/nb_host_death ;
	
	nb_death = 0 ; // Count the number of already dead hosts
	
	while	(nb_death<nb_host_death) // TO MODIFY : RECALCULATE THE PROBABILITY TO DRAW ONE CATEGORY THROUGH THE PROCESS?
	{
		// Generate a random numbers between 0 and 1 to determine the category of the dead host
		p = runif(n=1,min=0,max=1);
		
		death = 0 ;// No dead individual as long as death = 0, a dead individual if death =1
		// Randomly draw the host to die depending on p
		if (p<p_death_healthyH1)
		{
			if (p1.individuals[p1.individuals.tag==0 & p1.individuals.genome1.countOfMutationsOfType(m4)==0].size()>0) // At least one remaining individual in this category
			{
				dead_host = sample(p1.individuals[p1.individuals.tag==0 & p1.individuals.genome1.countOfMutationsOfType(m4)==0],1);
				death =1;
			}
		}
		else if (p<(p_death_healthyH1+p_death_healthyH2))
		{
			if (p1.individuals[p1.individuals.tag==0 & p1.individuals.genome1.countOfMutationsOfType(m4)==1].size()>0) // At least one remaining individual in this category
			{
				dead_host = sample(p1.individuals[p1.individuals.tag==0 & p1.individuals.genome1.countOfMutationsOfType(m4)==1],1);
				death =1;
			}
		}
		else if (p<(p_death_healthyH1+p_death_healthyH2+p_death_infectedH1))
		{
			if (p1.individuals[p1.individuals.tag==1 & p1.individuals.genome1.countOfMutationsOfType(m4)==0].size()>0) // At least one remaining individual in this category
			{
				dead_host = sample(p1.individuals[p1.individuals.tag==1 & p1.individuals.genome1.countOfMutationsOfType(m4)==0],1);
				death =1;
			}
		}
		else if (p<(p_death_healthyH1+p_death_healthyH2+p_death_infectedH1+p_death_infectedH2))
		{
			if (p1.individuals[p1.individuals.tag==1 & p1.individuals.genome1.countOfMutationsOfType(m4)==1].size()>0) // At least one remaining individual in this category
			{
				dead_host = sample(p1.individuals[p1.individuals.tag==1 & p1.individuals.genome1.countOfMutationsOfType(m4)==1],1);
				death =1;
			}
		}
		else
		{
			print(p);
			print(nb_death);
			print(nb_host_death);
		}
		
		if(death==1)
		{
			// Kill the host and its parasite if it exists
			hostID = dead_host.pedigreeID;
			parasiteSubpop = parasiteSubpops[parasiteSubpops.tag == hostID];
			// the host has died; kill it and its parasite
			host.killIndividuals(dead_host);
			parasiteSubpop.removeSubpopulation();
			
			nb_death = nb_death+1;
		}
	}
}

// ticks all 100 late() {
// Introduce one mutation in one host and one parasite individual at the selected locus at generation 100
//	targetH = sample(p1.individuals.genome1,1);
//	targetH.addNewDrawnMutation(m4, PositionSNP);
//}

//ticks all 150 late() {
//	parasiteSubpops = parasite.subpopulations;
//	allParasites = parasiteSubpops.individuals;
//	targetP = sample(allParasites.genome1,1);
//	targetP.addNewDrawnMutation(m2, PositionSNP);
//}

ticks all 500 late() {
}